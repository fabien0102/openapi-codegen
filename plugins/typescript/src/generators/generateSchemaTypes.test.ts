import { describe, expect, it, vi } from "vitest";
import { petstore } from "../fixtures/petstore";
import { generateSchemaTypes } from "./generateSchemaTypes";
import { createWriteFileMock } from "../testUtils";

describe("generateSchemaTypes", () => {
  describe("filenameCase option", () => {
    it("should generate files in camel case", async () => {
      const writeFile = createWriteFileMock();
      const readFile = vi.fn(() => Promise.resolve(""));

      await generateSchemaTypes(
        {
          openAPIDocument: petstore,
          writeFile,
          readFile,
          existsFile: () => true,
        },
        {
          filenameCase: "camel",
        }
      );
      expect(writeFile.mock.calls[0][0]).toBe("swaggerPetstoreSchemas.ts");
    });

    it("should generate files in snake case", async () => {
      const writeFile = createWriteFileMock();
      const readFile = vi.fn(() => Promise.resolve(""));

      await generateSchemaTypes(
        {
          openAPIDocument: petstore,
          writeFile,
          readFile,
          existsFile: () => true,
        },
        {
          filenameCase: "snake",
        }
      );
      expect(writeFile.mock.calls[0][0]).toBe("swagger_petstore_schemas.ts");
    });

    it("should generate files in kebab case", async () => {
      const writeFile = createWriteFileMock();
      const readFile = vi.fn(() => Promise.resolve(""));

      await generateSchemaTypes(
        {
          openAPIDocument: petstore,
          writeFile,
          readFile,
          existsFile: () => true,
        },
        {
          filenameCase: "kebab",
        }
      );
      expect(writeFile.mock.calls[0][0]).toBe("swagger-petstore-schemas.ts");
    });

    it("should generate files in pascal case", async () => {
      const writeFile = createWriteFileMock();
      const readFile = vi.fn(() => Promise.resolve(""));

      await generateSchemaTypes(
        {
          openAPIDocument: petstore,
          writeFile,
          readFile,
          existsFile: () => true,
        },
        {
          filenameCase: "pascal",
        }
      );
      expect(writeFile.mock.calls[0][0]).toBe("SwaggerPetstoreSchemas.ts");
    });
  });

  describe("filenamePrefix option", () => {
    it("should take have the correct prefix", async () => {
      const writeFile = createWriteFileMock();
      const readFile = vi.fn(() => Promise.resolve(""));
      await generateSchemaTypes(
        {
          openAPIDocument: petstore,
          writeFile,
          readFile,
          existsFile: () => true,
        },
        {
          filenameCase: "camel",
          filenamePrefix: "petstore",
        }
      );
      expect(writeFile.mock.calls[0][0]).toBe("petstoreSchemas.ts");
    });
  });

  describe("without filenamePrefix option", () => {
    it("should not have a prefix", async () => {
      const writeFile = createWriteFileMock();
      const readFile = vi.fn(() => Promise.resolve(""));
      await generateSchemaTypes(
        {
          openAPIDocument: petstore,
          writeFile,
          readFile,
          existsFile: () => true,
        },
        {
          filenameCase: "camel",
          filenamePrefix: "",
        }
      );
      expect(writeFile.mock.calls[0][0]).toBe("schemas.ts");
    });
  });

  describe("schemas file generation", () => {
    it("should generate the schemas file", async () => {
      const writeFile = createWriteFileMock();
      const readFile = vi.fn(() => Promise.resolve(""));
      await generateSchemaTypes(
        {
          openAPIDocument: petstore,
          writeFile,
          readFile,
          existsFile: () => true,
        },
        {
          filenameCase: "camel",
        }
      );
      expect(writeFile.mock.calls[0][0]).toBe("swaggerPetstoreSchemas.ts");
      expect(writeFile.mock.calls[0][1]).toMatchInlineSnapshot(`
        "/**
         * Generated by @openapi-codegen
         *
         * @version 1.0.0
         */
        /**
         * A new pet.
         */
        export type Pet = NewPet & {
          /**
           * @format int64
           */
          id: number;
        };

        /**
         * A new pet.
         */
        export type NewPet = {
          name: string;
          tag?: string;
        };

        /**
         * A discriminator example.
         */
        export type CatOrDog =
          | (Omit<Cat, "type"> & {
              type: "cat";
            })
          | (Omit<Dog, "type"> & {
              type: "dog";
            });

        /**
         * A cat, meow.
         */
        export type Cat = {
          type: string;
          breed: "labrador" | "carlin" | "beagle";
        };

        /**
         * A dog, wooof.
         */
        export type Dog = {
          type: string;
          breed: "saimois" | "bengal" | "british shorthair";
        };

        /**
         * An error :(
         */
        export type Error = {
          /**
           * @format int32
           */
          code: number;
          message: string;
        };

        /**
         * Request description
         */
        export type Request = {
          action?: ("create" | "read" | "update" | "delete")[];
        };
        "
      `);
    });

    it("should generate the schemas file with enums instead of string unions", async () => {
      const writeFile = createWriteFileMock();
      const readFile = vi.fn(() => Promise.resolve(""));
      await generateSchemaTypes(
        {
          openAPIDocument: petstore,
          writeFile,
          readFile,
          existsFile: () => true,
        },
        {
          filenameCase: "camel",
          useEnums: true,
        }
      );
      expect(writeFile.mock.calls[0][0]).toBe("swaggerPetstoreSchemas.ts");
      expect(writeFile.mock.calls[0][1]).toMatchInlineSnapshot(`
        "/**
         * Generated by @openapi-codegen
         *
         * @version 1.0.0
         */
        export enum CatBreed {
          Labrador = "labrador",
          Carlin = "carlin",
          Beagle = "beagle",
        }

        export enum DogBreed {
          Saimois = "saimois",
          Bengal = "bengal",
          BritishShorthair = "british shorthair",
        }

        /**
         * A new pet.
         */
        export type Pet = NewPet & {
          /**
           * @format int64
           */
          id: number;
        };

        /**
         * A new pet.
         */
        export type NewPet = {
          name: string;
          tag?: string;
        };

        /**
         * A discriminator example.
         */
        export type CatOrDog =
          | (Omit<Cat, "type"> & {
              type: "cat";
            })
          | (Omit<Dog, "type"> & {
              type: "dog";
            });

        /**
         * A cat, meow.
         */
        export type Cat = {
          type: string;
          breed: CatBreed;
        };

        /**
         * A dog, wooof.
         */
        export type Dog = {
          type: string;
          breed: DogBreed;
        };

        /**
         * An error :(
         */
        export type Error = {
          /**
           * @format int32
           */
          code: number;
          message: string;
        };

        /**
         * Request description
         */
        export type Request = {
          action?: ("create" | "read" | "update" | "delete")[];
        };
        "
      `);
    });

    it("should generate the responses file", async () => {
      const writeFile = createWriteFileMock();
      const readFile = vi.fn(() => Promise.resolve(""));
      await generateSchemaTypes(
        {
          openAPIDocument: petstore,
          writeFile,
          readFile,
          existsFile: () => true,
        },
        {
          filenameCase: "camel",
        }
      );
      expect(writeFile.mock.calls[1][0]).toBe("swaggerPetstoreResponses.ts");
      expect(writeFile.mock.calls[1][1]).toMatchInlineSnapshot(`
        "/**
         * Generated by @openapi-codegen
         *
         * @version 1.0.0
         */
        import type * as Schemas from "./swaggerPetstoreSchemas";

        export type NotModified = void;

        export type PetResponse = Schemas.Pet;

        export type PetTypeResponse = "cat" | "dog";
        "
      `);
    });

    it("should generate the request bodies file", async () => {
      const writeFile = createWriteFileMock();
      const readFile = vi.fn(() => Promise.resolve(""));
      await generateSchemaTypes(
        {
          openAPIDocument: petstore,
          writeFile,
          readFile,
          existsFile: () => true,
        },
        {
          filenameCase: "camel",
        }
      );
      expect(writeFile.mock.calls[2][0]).toBe(
        "swaggerPetstoreRequestBodies.ts"
      );
      expect(writeFile.mock.calls[2][1]).toMatchInlineSnapshot(`
        "/**
         * Generated by @openapi-codegen
         *
         * @version 1.0.0
         */
        import type * as Schemas from "./swaggerPetstoreSchemas";

        export type UpdatePetRequest = Schemas.NewPet;

        export type SearchPetRequest = "cat" | "dog";
        "
      `);
    });

    it("should generate the parameters file", async () => {
      const writeFile = createWriteFileMock();
      const readFile = vi.fn(() => Promise.resolve(""));

      await generateSchemaTypes(
        {
          openAPIDocument: petstore,
          writeFile,
          readFile,
          existsFile: () => true,
        },
        {
          filenameCase: "camel",
        }
      );
      expect(writeFile.mock.calls[3][0]).toBe("swaggerPetstoreParameters.ts");
      expect(writeFile.mock.calls[3][1]).toMatchInlineSnapshot(`
        "/**
         * Generated by @openapi-codegen
         *
         * @version 1.0.0
         */
        /**
         * Unique identifier
         */
        export type IdParam = string;

        /**
         * Filter by type
         */
        export type PetFilterParam = "cat" | "dog";
        "
      `);
    });

    it("should generate the responses file with enums instead of string unions", async () => {
      const writeFile = createWriteFileMock();
      const readFile = vi.fn(() => Promise.resolve(""));
      await generateSchemaTypes(
        {
          openAPIDocument: petstore,
          writeFile,
          readFile,
          existsFile: () => true,
        },
        {
          filenameCase: "camel",
          useEnums: true,
        }
      );
      expect(writeFile.mock.calls[1][0]).toBe("swaggerPetstoreResponses.ts");
      expect(writeFile.mock.calls[1][1]).toMatchInlineSnapshot(`
        "/**
         * Generated by @openapi-codegen
         *
         * @version 1.0.0
         */
        import type * as Schemas from "./swaggerPetstoreSchemas";

        export enum PetTypeResponse {
          Cat = "cat",
          Dog = "dog",
        }

        export type NotModified = void;

        export type PetResponse = Schemas.Pet;
        "
      `);
    });

    it("should generate the request bodies file with enums instead of string unions", async () => {
      const writeFile = createWriteFileMock();
      const readFile = vi.fn(() => Promise.resolve(""));
      await generateSchemaTypes(
        {
          openAPIDocument: petstore,
          writeFile,
          readFile,
          existsFile: () => true,
        },
        {
          filenameCase: "camel",
          useEnums: true,
        }
      );
      expect(writeFile.mock.calls[2][0]).toBe(
        "swaggerPetstoreRequestBodies.ts"
      );
      expect(writeFile.mock.calls[2][1]).toMatchInlineSnapshot(`
        "/**
         * Generated by @openapi-codegen
         *
         * @version 1.0.0
         */
        import type * as Schemas from "./swaggerPetstoreSchemas";

        export enum SearchPetRequest {
          Cat = "cat",
          Dog = "dog",
        }

        export type UpdatePetRequest = Schemas.NewPet;
        "
      `);
    });

    it("should generate the parameters file with enums instead of string unions", async () => {
      const writeFile = createWriteFileMock();
      const readFile = vi.fn(() => Promise.resolve(""));

      await generateSchemaTypes(
        {
          openAPIDocument: petstore,
          writeFile,
          readFile,
          existsFile: () => true,
        },
        {
          filenameCase: "camel",
          useEnums: true,
        }
      );
      expect(writeFile.mock.calls[3][0]).toBe("swaggerPetstoreParameters.ts");
      expect(writeFile.mock.calls[3][1]).toMatchInlineSnapshot(`
        "/**
         * Generated by @openapi-codegen
         *
         * @version 1.0.0
         */
        /**
         * Filter by type
         */
        export enum PetFilterParam {
          Cat = "cat",
          Dog = "dog",
        }

        /**
         * Unique identifier
         */
        export type IdParam = string;
        "
      `);
    });
  });
});
