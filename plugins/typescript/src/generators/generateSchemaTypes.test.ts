import { petstore } from "../fixtures/petstore";
import { generateSchemaTypes } from "./generateSchemaTypes";

describe("generateSchemaTypes", () => {
  describe("filenameCase option", () => {
    it("should generate files in camel case", () => {
      const writeFile = jest.fn();
      const readFile = jest.fn(() => Promise.resolve(""));

      generateSchemaTypes(
        {
          openAPIDocument: petstore,
          writeFile,
          readFile,
          existsFile: () => true,
        },
        {
          filenameCase: "camel",
        }
      );
      expect(writeFile.mock.calls[0][0]).toBe("swaggerPetstoreSchemas.ts");
    });

    it("should generate files in snake case", () => {
      const writeFile = jest.fn();
      const readFile = jest.fn(() => Promise.resolve(""));

      generateSchemaTypes(
        {
          openAPIDocument: petstore,
          writeFile,
          readFile,
          existsFile: () => true,
        },
        {
          filenameCase: "snake",
        }
      );
      expect(writeFile.mock.calls[0][0]).toBe("swagger_petstore_schemas.ts");
    });

    it("should generate files in kebab case", () => {
      const writeFile = jest.fn();
      const readFile = jest.fn(() => Promise.resolve(""));

      generateSchemaTypes(
        {
          openAPIDocument: petstore,
          writeFile,
          readFile,
          existsFile: () => true,
        },
        {
          filenameCase: "kebab",
        }
      );
      expect(writeFile.mock.calls[0][0]).toBe("swagger-petstore-schemas.ts");
    });

    it("should generate files in pascal case", () => {
      const writeFile = jest.fn();
      const readFile = jest.fn(() => Promise.resolve(""));

      generateSchemaTypes(
        {
          openAPIDocument: petstore,
          writeFile,
          readFile,
          existsFile: () => true,
        },
        {
          filenameCase: "pascal",
        }
      );
      expect(writeFile.mock.calls[0][0]).toBe("SwaggerPetstoreSchemas.ts");
    });
  });

  describe("filenamePrefix option", () => {
    it("should take have the correct prefix", () => {
      const writeFile = jest.fn();
      const readFile = jest.fn(() => Promise.resolve(""));
      generateSchemaTypes(
        {
          openAPIDocument: petstore,
          writeFile,
          readFile,
          existsFile: () => true,
        },
        {
          filenameCase: "camel",
          filenamePrefix: "petstore",
        }
      );
      expect(writeFile.mock.calls[0][0]).toBe("petstoreSchemas.ts");
    });
  });

  describe("without filenamePrefix option", () => {
    it("should not have a prefix", () => {
      const writeFile = jest.fn();
      const readFile = jest.fn(() => Promise.resolve(""));
      generateSchemaTypes(
        {
          openAPIDocument: petstore,
          writeFile,
          readFile,
          existsFile: () => true,
        },
        {
          filenameCase: "camel",
          filenamePrefix: "",
        }
      );
      expect(writeFile.mock.calls[0][0]).toBe("schemas.ts");
    });
  });

  describe("schemas file generation", () => {
    it("should generate the schemas file", async () => {
      const writeFile = jest.fn();
      const readFile = jest.fn(() => Promise.resolve(""));
      await generateSchemaTypes(
        {
          openAPIDocument: petstore,
          writeFile,
          readFile,
          existsFile: () => true,
        },
        {
          filenameCase: "camel",
        }
      );
      expect(writeFile.mock.calls[0][0]).toBe("swaggerPetstoreSchemas.ts");
      expect(writeFile.mock.calls[0][1]).toMatchInlineSnapshot(`
        "/**
         * Generated by @openapi-codegen
         * 
         * @version 1.0.0
         */
        /**
         * A new pet.
         */
        export type Pet = NewPet & {
            /**
             * @format int64
             */
            id: number;
        };

        /**
         * A new pet.
         */
        export type NewPet = {
            name: string;
            tag?: string;
        };

        /**
         * A discriminator example.
         */
        export type CatOrDog = (Omit<Cat, \\"type\\"> & {
            type: \\"cat\\";
        }) | (Omit<Dog, \\"type\\"> & {
            type: \\"dog\\";
        });

        /**
         * A cat, meow.
         */
        export type Cat = {
            type: string;
            breed: \\"labrador\\" | \\"carlin\\" | \\"beagle\\";
        };

        /**
         * A dog, wooof.
         */
        export type Dog = {
            type: string;
            breed: \\"saimois\\" | \\"bengal\\" | \\"british shorthair\\";
        };

        /**
         * An error :(
         */
        export type Error = {
            /**
             * @format int32
             */
            code: number;
            message: string;
        };

        /**
         * Request description
         */
        export type Request = {
            action?: (\\"create\\" | \\"read\\" | \\"update\\" | \\"delete\\")[];
        };
        "
      `);
    });

    it("should generate the schemas file with enums instead of string unions", async () => {
      const writeFile = jest.fn();
      const readFile = jest.fn(() => Promise.resolve(""));
      await generateSchemaTypes(
        {
          openAPIDocument: petstore,
          writeFile,
          readFile,
          existsFile: () => true,
        },
        {
          filenameCase: "camel",
          useEnums: true,
        }
      );
      expect(writeFile.mock.calls[0][0]).toBe("swaggerPetstoreSchemas.ts");
      expect(writeFile.mock.calls[0][1]).toMatchInlineSnapshot(`
        "/**
         * Generated by @openapi-codegen
         * 
         * @version 1.0.0
         */
        export enum CatBreed {
            labrador = \\"labrador\\",
            carlin = \\"carlin\\",
            beagle = \\"beagle\\"
        }

        export enum DogBreed {
            saimois = \\"saimois\\",
            bengal = \\"bengal\\",
            british shorthair = \\"british shorthair\\"
        }

        /**
         * A new pet.
         */
        export type Pet = NewPet & {
            /**
             * @format int64
             */
            id: number;
        };

        /**
         * A new pet.
         */
        export type NewPet = {
            name: string;
            tag?: string;
        };

        /**
         * A discriminator example.
         */
        export type CatOrDog = (Omit<Cat, \\"type\\"> & {
            type: \\"cat\\";
        }) | (Omit<Dog, \\"type\\"> & {
            type: \\"dog\\";
        });

        /**
         * A cat, meow.
         */
        export type Cat = {
            type: string;
            breed: CatBreed;
        };

        /**
         * A dog, wooof.
         */
        export type Dog = {
            type: string;
            breed: DogBreed;
        };

        /**
         * An error :(
         */
        export type Error = {
            /**
             * @format int32
             */
            code: number;
            message: string;
        };

        /**
         * Request description
         */
        export type Request = {
            action?: (\\"create\\" | \\"read\\" | \\"update\\" | \\"delete\\")[];
        };
        "
      `);
    });

    it("should generate the responses file", async () => {
      const writeFile = jest.fn();
      const readFile = jest.fn(() => Promise.resolve(""));
      await generateSchemaTypes(
        {
          openAPIDocument: petstore,
          writeFile,
          readFile,
          existsFile: () => true,
        },
        {
          filenameCase: "camel",
        }
      );
      expect(writeFile.mock.calls[1][0]).toBe("swaggerPetstoreResponses.ts");
      expect(writeFile.mock.calls[1][1]).toMatchInlineSnapshot(`
        "/**
         * Generated by @openapi-codegen
         * 
         * @version 1.0.0
         */
        import type * as Schemas from \\"./swaggerPetstoreSchemas\\";

        export type NotModified = void;

        export type PetResponse = Schemas.Pet;
        "
      `);
    });

    it("should generate the request bodies file", async () => {
      const writeFile = jest.fn();
      const readFile = jest.fn(() => Promise.resolve(""));
      await generateSchemaTypes(
        {
          openAPIDocument: petstore,
          writeFile,
          readFile,
          existsFile: () => true,
        },
        {
          filenameCase: "camel",
        }
      );
      expect(writeFile.mock.calls[2][0]).toBe(
        "swaggerPetstoreRequestBodies.ts"
      );
      expect(writeFile.mock.calls[2][1]).toMatchInlineSnapshot(`
        "/**
         * Generated by @openapi-codegen
         * 
         * @version 1.0.0
         */
        import type * as Schemas from \\"./swaggerPetstoreSchemas\\";

        export type UpdatePetRequest = Schemas.NewPet;
        "
      `);
    });

    it("should generate the parameters file", async () => {
      const writeFile = jest.fn();
      const readFile = jest.fn(() => Promise.resolve(""));

      await generateSchemaTypes(
        {
          openAPIDocument: petstore,
          writeFile,
          readFile,
          existsFile: () => true,
        },
        {
          filenameCase: "camel",
        }
      );
      expect(writeFile.mock.calls[3][0]).toBe("swaggerPetstoreParameters.ts");
      expect(writeFile.mock.calls[3][1]).toMatchInlineSnapshot(`
        "/**
         * Generated by @openapi-codegen
         * 
         * @version 1.0.0
         */
        /**
         * Unique identifier
         */
        export type IdParam = string;
        "
      `);
    });
  });
});
