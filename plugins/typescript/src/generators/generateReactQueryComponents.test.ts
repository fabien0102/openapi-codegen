import { OpenAPIObject } from "openapi3-ts";
import {
  Config,
  generateReactQueryComponents,
} from "./generateReactQueryComponents";

const config: Config = {
  filenamePrefix: "petstore",
  schemasFiles: {
    parameters: "petstoreParameters",
    schemas: "petstoreSchemas",
    responses: "petstoreResponses",
    requestBodies: "petstoreRequestBodies",
  },
};

describe("generateReactQueryComponents", () => {
  it("should inject the customFetch import", async () => {
    const writeFile = jest.fn();
    const openAPIDocument: OpenAPIObject = {
      openapi: "3.0.0",
      info: {
        title: "petshop",
        version: "1.0.0",
      },
      paths: {},
    };

    await generateReactQueryComponents(
      {
        openAPIDocument,
        writeFile,
        existsFile: () => false, // customFetcher is not there
        readFile: async () => "",
      },
      config,
    );

    expect(writeFile.mock.calls[0][0]).toBe("petstoreFetcher.ts");
  });

  it("should generate a useQuery wrapper (no parameters)", async () => {
    const writeFile = jest.fn();
    const openAPIDocument: OpenAPIObject = {
      openapi: "3.0.0",
      info: {
        title: "petshop",
        version: "1.0.0",
      },
      paths: {
        "/pets": {
          get: {
            operationId: "listPets",
            description: "Get all the pets",
            responses: {
              "200": {
                description: "pet response",
                content: {
                  "application/json": {
                    schema: {
                      type: "array",
                      items: {
                        $ref: "#/components/schemas/Pet",
                      },
                    },
                  },
                },
              },
            },
          },
        },
      },
    };

    await generateReactQueryComponents(
      {
        openAPIDocument,
        writeFile,
        existsFile: () => true,
        readFile: async () => "",
      },
      config,
    );

    expect(writeFile.mock.calls[0][0]).toBe("petstoreComponents.ts");
    expect(writeFile.mock.calls[0][1]).toMatchInlineSnapshot(`
     "/**
      * Generated by @openapi-codegen
      * 
      * @version 1.0.0
      */
     import * as reactQuery from "@tanstack/react-query";
     import { usePetstoreContext, PetstoreContext } from "./petstoreContext";
     import type * as Fetcher from "./petstoreFetcher";
     import { petstoreFetch } from "./petstoreFetcher";
     import type * as Schemas from "./petstoreSchemas";

     export type ListPetsError = Fetcher.ErrorWrapper<undefined>;

     export type ListPetsResponse = Schemas.Pet[];

     export type ListPetsVariables = PetstoreContext["fetcherOptions"];

     /**
      * Get all the pets
      */
     export const fetchListPets = (variables: ListPetsVariables, signal?: AbortSignal) => petstoreFetch<ListPetsResponse, ListPetsError, undefined, {}, {}, {}>({ url: "/pets", method: "get", ...variables, signal });

     /**
      * Get all the pets
      */
     export const useListPets = <TData = ListPetsResponse>(variables: ListPetsVariables, options?: Omit<reactQuery.UseQueryOptions<ListPetsResponse, ListPetsError, TData>, "queryKey" | "queryFn" | "initialData">) => { const { fetcherOptions, queryOptions, queryKeyFn } = usePetstoreContext(options); return reactQuery.useQuery<ListPetsResponse, ListPetsError, TData>({
         queryKey: queryKeyFn({ path: "/pets", operationId: "listPets", variables }),
         queryFn: ({ signal }) => fetchListPets({ ...fetcherOptions, ...variables }, signal),
         ...options,
         ...queryOptions
     }); };

     export type QueryOperation = {
         path: "/pets";
         operationId: "listPets";
         variables: ListPetsVariables;
     };
     "
    `);
  });
  it("should generate a useSuspenseQuery wrapper (no parameters)", async () => {
    const writeFile = jest.fn();
    const openAPIDocument: OpenAPIObject = {
      openapi: "3.0.0",
      info: {
        title: "petshop",
        version: "1.0.0",
      },
      paths: {
        "/pets": {
          get: {
            operationId: "listPets",
            description: "Get all the pets",
            responses: {
              "200": {
                description: "pet response",
                content: {
                  "application/json": {
                    schema: {
                      type: "array",
                      items: {
                        $ref: "#/components/schemas/Pet",
                      },
                    },
                  },
                },
              },
            },
          },
        },
      },
    };

    await generateReactQueryComponents(
      {
        openAPIDocument,
        writeFile,
        existsFile: () => true,
        readFile: async () => "",
      },
      { ...config, generateSuspenseQueries: true },
    );

    expect(writeFile.mock.calls[0][0]).toBe("petstoreComponents.ts");
    expect(writeFile.mock.calls[0][1]).toMatchInlineSnapshot(`
     "/**
      * Generated by @openapi-codegen
      * 
      * @version 1.0.0
      */
     import * as reactQuery from "@tanstack/react-query";
     import { usePetstoreContext, PetstoreContext } from "./petstoreContext";
     import type * as Fetcher from "./petstoreFetcher";
     import { petstoreFetch } from "./petstoreFetcher";
     import type * as Schemas from "./petstoreSchemas";

     export type ListPetsError = Fetcher.ErrorWrapper<undefined>;

     export type ListPetsResponse = Schemas.Pet[];

     export type ListPetsVariables = PetstoreContext["fetcherOptions"];

     /**
      * Get all the pets
      */
     export const fetchListPets = (variables: ListPetsVariables, signal?: AbortSignal) => petstoreFetch<ListPetsResponse, ListPetsError, undefined, {}, {}, {}>({ url: "/pets", method: "get", ...variables, signal });

     /**
      * Get all the pets
      */
     export const useListPets = <TData = ListPetsResponse>(variables: ListPetsVariables, options?: Omit<reactQuery.UseQueryOptions<ListPetsResponse, ListPetsError, TData>, "queryKey" | "queryFn" | "initialData">) => { const { fetcherOptions, queryOptions, queryKeyFn } = usePetstoreContext(options); return reactQuery.useQuery<ListPetsResponse, ListPetsError, TData>({
         queryKey: queryKeyFn({ path: "/pets", operationId: "listPets", variables }),
         queryFn: ({ signal }) => fetchListPets({ ...fetcherOptions, ...variables }, signal),
         ...options,
         ...queryOptions
     }); };

     /**
      * Get all the pets
      */
     export const useSuspenseListPets = <TData = ListPetsResponse>(variables: ListPetsVariables, options?: Omit<reactQuery.UseQueryOptions<ListPetsResponse, ListPetsError, TData>, "queryKey" | "queryFn" | "initialData">) => { const { fetcherOptions, queryOptions, queryKeyFn } = usePetstoreContext(options); return reactQuery.useSuspenseQuery<ListPetsResponse, ListPetsError, TData>({
         queryKey: queryKeyFn({ path: "/pets", operationId: "listPets", variables }),
         queryFn: ({ signal }) => fetchListPets({ ...fetcherOptions, ...variables }, signal),
         ...options,
         ...queryOptions
     }); };

     export type QueryOperation = {
         path: "/pets";
         operationId: "listPets";
         variables: ListPetsVariables;
     };
     "
    `);
  });
  it("should generate a useQuery wrapper (with queryParams)", async () => {
    const writeFile = jest.fn();
    const openAPIDocument: OpenAPIObject = {
      openapi: "3.0.0",
      info: {
        title: "petshop",
        version: "1.0.0",
      },
      paths: {
        "/pets": {
          get: {
            operationId: "listPets",
            description: "Get all the pets",
            parameters: [
              {
                in: "query",
                name: "breed",
                description: "Filter on the dog breed",
                required: true,
                schema: {
                  type: "string",
                },
              },
              { $ref: "#/components/parameters/colorParam" },
            ],
            responses: {
              "200": {
                description: "pet response",
                content: {
                  "application/json": {
                    schema: {
                      type: "array",
                      items: {
                        $ref: "#/components/schemas/Pet",
                      },
                    },
                  },
                },
              },
            },
          },
        },
      },
      components: {
        parameters: {
          colorParam: {
            in: "query",
            description: "Color of the dog",
            name: "color",
            schema: {
              type: "string",
              enum: ["white", "black", "grey"],
            },
          },
        },
      },
    };

    await generateReactQueryComponents(
      {
        openAPIDocument,
        writeFile,
        existsFile: () => true,
        readFile: async () => "",
      },
      config,
    );

    expect(writeFile.mock.calls[0][0]).toBe("petstoreComponents.ts");
    expect(writeFile.mock.calls[0][1]).toMatchInlineSnapshot(`
     "/**
      * Generated by @openapi-codegen
      * 
      * @version 1.0.0
      */
     import * as reactQuery from "@tanstack/react-query";
     import { usePetstoreContext, PetstoreContext } from "./petstoreContext";
     import type * as Fetcher from "./petstoreFetcher";
     import { petstoreFetch } from "./petstoreFetcher";
     import type * as Schemas from "./petstoreSchemas";

     export type ListPetsQueryParams = {
         /**
          * Filter on the dog breed
          */
         breed: string;
         /**
          * Color of the dog
          */
         color?: "white" | "black" | "grey";
     };

     export type ListPetsError = Fetcher.ErrorWrapper<undefined>;

     export type ListPetsResponse = Schemas.Pet[];

     export type ListPetsVariables = {
         queryParams: ListPetsQueryParams;
     } & PetstoreContext["fetcherOptions"];

     /**
      * Get all the pets
      */
     export const fetchListPets = (variables: ListPetsVariables, signal?: AbortSignal) => petstoreFetch<ListPetsResponse, ListPetsError, undefined, {}, ListPetsQueryParams, {}>({ url: "/pets", method: "get", ...variables, signal });

     /**
      * Get all the pets
      */
     export const useListPets = <TData = ListPetsResponse>(variables: ListPetsVariables, options?: Omit<reactQuery.UseQueryOptions<ListPetsResponse, ListPetsError, TData>, "queryKey" | "queryFn" | "initialData">) => { const { fetcherOptions, queryOptions, queryKeyFn } = usePetstoreContext(options); return reactQuery.useQuery<ListPetsResponse, ListPetsError, TData>({
         queryKey: queryKeyFn({ path: "/pets", operationId: "listPets", variables }),
         queryFn: ({ signal }) => fetchListPets({ ...fetcherOptions, ...variables }, signal),
         ...options,
         ...queryOptions
     }); };

     export type QueryOperation = {
         path: "/pets";
         operationId: "listPets";
         variables: ListPetsVariables;
     };
     "
    `);
  });
  it("should generate a useSuspenseQuery wrapper (with queryParams)", async () => {
    const writeFile = jest.fn();
    const openAPIDocument: OpenAPIObject = {
      openapi: "3.0.0",
      info: {
        title: "petshop",
        version: "1.0.0",
      },
      paths: {
        "/pets": {
          get: {
            operationId: "listPets",
            description: "Get all the pets",
            parameters: [
              {
                in: "query",
                name: "breed",
                description: "Filter on the dog breed",
                required: true,
                schema: {
                  type: "string",
                },
              },
              { $ref: "#/components/parameters/colorParam" },
            ],
            responses: {
              "200": {
                description: "pet response",
                content: {
                  "application/json": {
                    schema: {
                      type: "array",
                      items: {
                        $ref: "#/components/schemas/Pet",
                      },
                    },
                  },
                },
              },
            },
          },
        },
      },
      components: {
        parameters: {
          colorParam: {
            in: "query",
            description: "Color of the dog",
            name: "color",
            schema: {
              type: "string",
              enum: ["white", "black", "grey"],
            },
          },
        },
      },
    };

    await generateReactQueryComponents(
      {
        openAPIDocument,
        writeFile,
        existsFile: () => true,
        readFile: async () => "",
      },
      { ...config, generateSuspenseQueries: true },
    );

    expect(writeFile.mock.calls[0][0]).toBe("petstoreComponents.ts");
    expect(writeFile.mock.calls[0][1]).toMatchInlineSnapshot(`
     "/**
      * Generated by @openapi-codegen
      * 
      * @version 1.0.0
      */
     import * as reactQuery from "@tanstack/react-query";
     import { usePetstoreContext, PetstoreContext } from "./petstoreContext";
     import type * as Fetcher from "./petstoreFetcher";
     import { petstoreFetch } from "./petstoreFetcher";
     import type * as Schemas from "./petstoreSchemas";

     export type ListPetsQueryParams = {
         /**
          * Filter on the dog breed
          */
         breed: string;
         /**
          * Color of the dog
          */
         color?: "white" | "black" | "grey";
     };

     export type ListPetsError = Fetcher.ErrorWrapper<undefined>;

     export type ListPetsResponse = Schemas.Pet[];

     export type ListPetsVariables = {
         queryParams: ListPetsQueryParams;
     } & PetstoreContext["fetcherOptions"];

     /**
      * Get all the pets
      */
     export const fetchListPets = (variables: ListPetsVariables, signal?: AbortSignal) => petstoreFetch<ListPetsResponse, ListPetsError, undefined, {}, ListPetsQueryParams, {}>({ url: "/pets", method: "get", ...variables, signal });

     /**
      * Get all the pets
      */
     export const useListPets = <TData = ListPetsResponse>(variables: ListPetsVariables, options?: Omit<reactQuery.UseQueryOptions<ListPetsResponse, ListPetsError, TData>, "queryKey" | "queryFn" | "initialData">) => { const { fetcherOptions, queryOptions, queryKeyFn } = usePetstoreContext(options); return reactQuery.useQuery<ListPetsResponse, ListPetsError, TData>({
         queryKey: queryKeyFn({ path: "/pets", operationId: "listPets", variables }),
         queryFn: ({ signal }) => fetchListPets({ ...fetcherOptions, ...variables }, signal),
         ...options,
         ...queryOptions
     }); };

     /**
      * Get all the pets
      */
     export const useSuspenseListPets = <TData = ListPetsResponse>(variables: ListPetsVariables, options?: Omit<reactQuery.UseQueryOptions<ListPetsResponse, ListPetsError, TData>, "queryKey" | "queryFn" | "initialData">) => { const { fetcherOptions, queryOptions, queryKeyFn } = usePetstoreContext(options); return reactQuery.useSuspenseQuery<ListPetsResponse, ListPetsError, TData>({
         queryKey: queryKeyFn({ path: "/pets", operationId: "listPets", variables }),
         queryFn: ({ signal }) => fetchListPets({ ...fetcherOptions, ...variables }, signal),
         ...options,
         ...queryOptions
     }); };

     export type QueryOperation = {
         path: "/pets";
         operationId: "listPets";
         variables: ListPetsVariables;
     };
     "
    `);
  });
  it("should generate a useQuery wrapper (with pathParams)", async () => {
    const writeFile = jest.fn();
    const openAPIDocument: OpenAPIObject = {
      openapi: "3.0.0",
      info: {
        title: "petshop",
        version: "1.0.0",
      },
      paths: {
        "/pets/{pet_id}": {
          get: {
            operationId: "showPetById",
            description: "Info for a specific pet",
            parameters: [
              {
                in: "path",
                name: "pet_id",
                description: "The id of the pet to retrieve",
                required: true,
                schema: {
                  type: "string",
                },
              },
            ],
            responses: {
              "200": {
                description: "pet response",
                content: {
                  "application/json": {
                    schema: {
                      type: "array",
                      items: {
                        $ref: "#/components/schemas/Pet",
                      },
                    },
                  },
                },
              },
            },
          },
        },
      },
    };

    await generateReactQueryComponents(
      {
        openAPIDocument,
        writeFile,
        existsFile: () => true,
        readFile: async () => "",
      },
      config,
    );

    expect(writeFile.mock.calls[0][0]).toBe("petstoreComponents.ts");
    expect(writeFile.mock.calls[0][1]).toMatchInlineSnapshot(`
     "/**
      * Generated by @openapi-codegen
      * 
      * @version 1.0.0
      */
     import * as reactQuery from "@tanstack/react-query";
     import { usePetstoreContext, PetstoreContext } from "./petstoreContext";
     import type * as Fetcher from "./petstoreFetcher";
     import { petstoreFetch } from "./petstoreFetcher";
     import type * as Schemas from "./petstoreSchemas";

     export type ShowPetByIdPathParams = {
         /**
          * The id of the pet to retrieve
          */
         petId: string;
     };

     export type ShowPetByIdError = Fetcher.ErrorWrapper<undefined>;

     export type ShowPetByIdResponse = Schemas.Pet[];

     export type ShowPetByIdVariables = {
         pathParams: ShowPetByIdPathParams;
     } & PetstoreContext["fetcherOptions"];

     /**
      * Info for a specific pet
      */
     export const fetchShowPetById = (variables: ShowPetByIdVariables, signal?: AbortSignal) => petstoreFetch<ShowPetByIdResponse, ShowPetByIdError, undefined, {}, {}, ShowPetByIdPathParams>({ url: "/pets/{petId}", method: "get", ...variables, signal });

     /**
      * Info for a specific pet
      */
     export const useShowPetById = <TData = ShowPetByIdResponse>(variables: ShowPetByIdVariables, options?: Omit<reactQuery.UseQueryOptions<ShowPetByIdResponse, ShowPetByIdError, TData>, "queryKey" | "queryFn" | "initialData">) => { const { fetcherOptions, queryOptions, queryKeyFn } = usePetstoreContext(options); return reactQuery.useQuery<ShowPetByIdResponse, ShowPetByIdError, TData>({
         queryKey: queryKeyFn({ path: "/pets/{petId}", operationId: "showPetById", variables }),
         queryFn: ({ signal }) => fetchShowPetById({ ...fetcherOptions, ...variables }, signal),
         ...options,
         ...queryOptions
     }); };

     export type QueryOperation = {
         path: "/pets/{petId}";
         operationId: "showPetById";
         variables: ShowPetByIdVariables;
     };
     "
    `);
  });

  it("should generate a useSuspenseQuery wrapper (with pathParams)", async () => {
    const writeFile = jest.fn();
    const openAPIDocument: OpenAPIObject = {
      openapi: "3.0.0",
      info: {
        title: "petshop",
        version: "1.0.0",
      },
      paths: {
        "/pets/{pet_id}": {
          get: {
            operationId: "showPetById",
            description: "Info for a specific pet",
            parameters: [
              {
                in: "path",
                name: "pet_id",
                description: "The id of the pet to retrieve",
                required: true,
                schema: {
                  type: "string",
                },
              },
            ],
            responses: {
              "200": {
                description: "pet response",
                content: {
                  "application/json": {
                    schema: {
                      type: "array",
                      items: {
                        $ref: "#/components/schemas/Pet",
                      },
                    },
                  },
                },
              },
            },
          },
        },
      },
    };

    await generateReactQueryComponents(
      {
        openAPIDocument,
        writeFile,
        existsFile: () => true,
        readFile: async () => "",
      },
      { ...config, generateSuspenseQueries: true },
    );

    expect(writeFile.mock.calls[0][0]).toBe("petstoreComponents.ts");
    expect(writeFile.mock.calls[0][1]).toMatchInlineSnapshot(`
     "/**
      * Generated by @openapi-codegen
      * 
      * @version 1.0.0
      */
     import * as reactQuery from "@tanstack/react-query";
     import { usePetstoreContext, PetstoreContext } from "./petstoreContext";
     import type * as Fetcher from "./petstoreFetcher";
     import { petstoreFetch } from "./petstoreFetcher";
     import type * as Schemas from "./petstoreSchemas";

     export type ShowPetByIdPathParams = {
         /**
          * The id of the pet to retrieve
          */
         petId: string;
     };

     export type ShowPetByIdError = Fetcher.ErrorWrapper<undefined>;

     export type ShowPetByIdResponse = Schemas.Pet[];

     export type ShowPetByIdVariables = {
         pathParams: ShowPetByIdPathParams;
     } & PetstoreContext["fetcherOptions"];

     /**
      * Info for a specific pet
      */
     export const fetchShowPetById = (variables: ShowPetByIdVariables, signal?: AbortSignal) => petstoreFetch<ShowPetByIdResponse, ShowPetByIdError, undefined, {}, {}, ShowPetByIdPathParams>({ url: "/pets/{petId}", method: "get", ...variables, signal });

     /**
      * Info for a specific pet
      */
     export const useShowPetById = <TData = ShowPetByIdResponse>(variables: ShowPetByIdVariables, options?: Omit<reactQuery.UseQueryOptions<ShowPetByIdResponse, ShowPetByIdError, TData>, "queryKey" | "queryFn" | "initialData">) => { const { fetcherOptions, queryOptions, queryKeyFn } = usePetstoreContext(options); return reactQuery.useQuery<ShowPetByIdResponse, ShowPetByIdError, TData>({
         queryKey: queryKeyFn({ path: "/pets/{petId}", operationId: "showPetById", variables }),
         queryFn: ({ signal }) => fetchShowPetById({ ...fetcherOptions, ...variables }, signal),
         ...options,
         ...queryOptions
     }); };

     /**
      * Info for a specific pet
      */
     export const useSuspenseShowPetById = <TData = ShowPetByIdResponse>(variables: ShowPetByIdVariables, options?: Omit<reactQuery.UseQueryOptions<ShowPetByIdResponse, ShowPetByIdError, TData>, "queryKey" | "queryFn" | "initialData">) => { const { fetcherOptions, queryOptions, queryKeyFn } = usePetstoreContext(options); return reactQuery.useSuspenseQuery<ShowPetByIdResponse, ShowPetByIdError, TData>({
         queryKey: queryKeyFn({ path: "/pets/{petId}", operationId: "showPetById", variables }),
         queryFn: ({ signal }) => fetchShowPetById({ ...fetcherOptions, ...variables }, signal),
         ...options,
         ...queryOptions
     }); };

     export type QueryOperation = {
         path: "/pets/{petId}";
         operationId: "showPetById";
         variables: ShowPetByIdVariables;
     };
     "
    `);
  });

  it("should deal with injected headers (marked them as optional)", async () => {
    const writeFile = jest.fn();
    const openAPIDocument: OpenAPIObject = {
      openapi: "3.0.0",
      info: {
        title: "petshop",
        version: "1.0.0",
      },
      paths: {
        "/pets": {
          get: {
            operationId: "listPets",
            description: "Get all the pets",
            parameters: [
              {
                in: "header",
                name: "breed",
                description: "Filter on the dog breed",
                required: true,
                schema: {
                  type: "string",
                },
              },
              { $ref: "#/components/parameters/colorParam" },
            ],
            responses: {
              "200": {
                description: "pet response",
                content: {
                  "application/json": {
                    schema: {
                      type: "array",
                      items: {
                        $ref: "#/components/schemas/Pet",
                      },
                    },
                  },
                },
              },
            },
          },
        },
      },
      components: {
        parameters: {
          colorParam: {
            in: "query",
            description: "Color of the dog",
            name: "color",
            schema: {
              type: "string",
              enum: ["white", "black", "grey"],
            },
          },
        },
      },
    };

    await generateReactQueryComponents(
      {
        openAPIDocument,
        writeFile,
        existsFile: () => true,
        readFile: async () => "",
      },
      { ...config, injectedHeaders: ["breed"] },
    );

    expect(writeFile.mock.calls[0][0]).toBe("petstoreComponents.ts");
    expect(writeFile.mock.calls[0][1]).toMatchInlineSnapshot(`
     "/**
      * Generated by @openapi-codegen
      * 
      * @version 1.0.0
      */
     import * as reactQuery from "@tanstack/react-query";
     import { usePetstoreContext, PetstoreContext } from "./petstoreContext";
     import type * as Fetcher from "./petstoreFetcher";
     import { petstoreFetch } from "./petstoreFetcher";
     import type * as Schemas from "./petstoreSchemas";

     export type ListPetsQueryParams = {
         /**
          * Color of the dog
          */
         color?: "white" | "black" | "grey";
     };

     export type ListPetsHeaders = {
         /**
          * Filter on the dog breed
          */
         breed?: string;
     };

     export type ListPetsError = Fetcher.ErrorWrapper<undefined>;

     export type ListPetsResponse = Schemas.Pet[];

     export type ListPetsVariables = {
         headers?: ListPetsHeaders;
         queryParams?: ListPetsQueryParams;
     } & PetstoreContext["fetcherOptions"];

     /**
      * Get all the pets
      */
     export const fetchListPets = (variables: ListPetsVariables, signal?: AbortSignal) => petstoreFetch<ListPetsResponse, ListPetsError, undefined, ListPetsHeaders, ListPetsQueryParams, {}>({ url: "/pets", method: "get", ...variables, signal });

     /**
      * Get all the pets
      */
     export const useListPets = <TData = ListPetsResponse>(variables: ListPetsVariables, options?: Omit<reactQuery.UseQueryOptions<ListPetsResponse, ListPetsError, TData>, "queryKey" | "queryFn" | "initialData">) => { const { fetcherOptions, queryOptions, queryKeyFn } = usePetstoreContext(options); return reactQuery.useQuery<ListPetsResponse, ListPetsError, TData>({
         queryKey: queryKeyFn({ path: "/pets", operationId: "listPets", variables }),
         queryFn: ({ signal }) => fetchListPets({ ...fetcherOptions, ...variables }, signal),
         ...options,
         ...queryOptions
     }); };

     export type QueryOperation = {
         path: "/pets";
         operationId: "listPets";
         variables: ListPetsVariables;
     };
     "
    `);
  });

  it("should not generated duplicated types", async () => {
    const writeFile = jest.fn();
    const openAPIDocument: OpenAPIObject = {
      openapi: "3.0.0",
      info: {
        title: "petshop",
        version: "1.0.0",
      },
      paths: {
        "/pets": {
          get: {
            operationId: "listPets",
            description: "Get all the pets",
            responses: {
              "200": {
                description: "pet response",
                content: {
                  "application/json": {
                    schema: {
                      type: "array",
                      items: {
                        $ref: "#/components/schemas/Pet",
                      },
                    },
                  },
                },
              },
              "201": {
                description: "pet response",
                content: {
                  "application/json": {
                    schema: {
                      type: "array",
                      items: {
                        $ref: "#/components/schemas/Pet",
                      },
                    },
                  },
                },
              },
            },
          },
        },
      },
    };

    await generateReactQueryComponents(
      {
        openAPIDocument,
        writeFile,
        existsFile: () => true,
        readFile: async () => "",
      },
      config,
    );

    expect(writeFile.mock.calls[0][0]).toBe("petstoreComponents.ts");
    expect(writeFile.mock.calls[0][1]).toMatchInlineSnapshot(`
     "/**
      * Generated by @openapi-codegen
      * 
      * @version 1.0.0
      */
     import * as reactQuery from "@tanstack/react-query";
     import { usePetstoreContext, PetstoreContext } from "./petstoreContext";
     import type * as Fetcher from "./petstoreFetcher";
     import { petstoreFetch } from "./petstoreFetcher";
     import type * as Schemas from "./petstoreSchemas";

     export type ListPetsError = Fetcher.ErrorWrapper<undefined>;

     export type ListPetsResponse = Schemas.Pet[];

     export type ListPetsVariables = PetstoreContext["fetcherOptions"];

     /**
      * Get all the pets
      */
     export const fetchListPets = (variables: ListPetsVariables, signal?: AbortSignal) => petstoreFetch<ListPetsResponse, ListPetsError, undefined, {}, {}, {}>({ url: "/pets", method: "get", ...variables, signal });

     /**
      * Get all the pets
      */
     export const useListPets = <TData = ListPetsResponse>(variables: ListPetsVariables, options?: Omit<reactQuery.UseQueryOptions<ListPetsResponse, ListPetsError, TData>, "queryKey" | "queryFn" | "initialData">) => { const { fetcherOptions, queryOptions, queryKeyFn } = usePetstoreContext(options); return reactQuery.useQuery<ListPetsResponse, ListPetsError, TData>({
         queryKey: queryKeyFn({ path: "/pets", operationId: "listPets", variables }),
         queryFn: ({ signal }) => fetchListPets({ ...fetcherOptions, ...variables }, signal),
         ...options,
         ...queryOptions
     }); };

     export type QueryOperation = {
         path: "/pets";
         operationId: "listPets";
         variables: ListPetsVariables;
     };
     "
    `);
  });

  it("should generate useMutation for POST operation", async () => {
    const writeFile = jest.fn();
    const openAPIDocument: OpenAPIObject = {
      openapi: "3.0.0",
      info: {
        title: "petshop",
        version: "1.0.0",
      },
      paths: {
        "/pet": {
          post: {
            operationId: "AddPet",
            requestBody: {
              content: {
                "application/json": {
                  schema: {
                    type: "object",
                    properties: {
                      name: {
                        type: "string",
                      },
                      color: {
                        type: "string",
                      },
                      breed: {
                        type: "string",
                      },
                      age: {
                        type: "integer",
                      },
                    },
                    required: ["name", "breed", "age"],
                  },
                },
              },
            },
            responses: {
              200: {
                content: {
                  "application/json": {
                    description: "Successful response",
                    schema: {
                      type: "string",
                    },
                  },
                },
              },
              500: {
                content: {
                  "application/json": {
                    description: "An Error",
                    schema: {
                      type: "object",
                      properties: {
                        code: {
                          type: "integer",
                          enum: [500],
                        },
                        message: {
                          type: "string",
                        },
                      },
                      required: ["code", "message"],
                    },
                  },
                },
              },
            },
          },
        },
      },
    };

    await generateReactQueryComponents(
      {
        openAPIDocument,
        writeFile,
        existsFile: () => true,
        readFile: async () => "",
      },
      config,
    );

    expect(writeFile.mock.calls[0][0]).toBe("petstoreComponents.ts");
    expect(writeFile.mock.calls[0][1]).toMatchInlineSnapshot(`
     "/**
      * Generated by @openapi-codegen
      * 
      * @version 1.0.0
      */
     import * as reactQuery from "@tanstack/react-query";
     import { usePetstoreContext, PetstoreContext } from "./petstoreContext";
     import type * as Fetcher from "./petstoreFetcher";
     import { petstoreFetch } from "./petstoreFetcher";

     export type AddPetError = Fetcher.ErrorWrapper<{
         status: 500;
         payload: {
             code: 500;
             message: string;
         };
     }>;

     export type AddPetRequestBody = {
         name: string;
         color?: string;
         breed: string;
         age: number;
     };

     export type AddPetVariables = {
         body: AddPetRequestBody;
     } & PetstoreContext["fetcherOptions"];

     export const fetchAddPet = (variables: AddPetVariables, signal?: AbortSignal) => petstoreFetch<string, AddPetError, AddPetRequestBody, {}, {}, {}>({ url: "/pet", method: "post", ...variables, signal });

     export const useAddPet = (options?: Omit<reactQuery.UseMutationOptions<string, AddPetError, AddPetVariables>, "mutationFn">) => {
         const { fetcherOptions } = usePetstoreContext();
         return reactQuery.useMutation<string, AddPetError, AddPetVariables>({
             mutationFn: (variables: AddPetVariables) => fetchAddPet({ ...fetcherOptions, ...variables }),
             ...options
         });
     };

     export type QueryOperation = {
         path: string;
         operationId: never;
         variables: unknown;
     };
     "
    `);
  });

  it("should generate useMutation if openapi-codegen-component is defined", async () => {
    const writeFile = jest.fn();
    const openAPIDocument: OpenAPIObject = {
      openapi: "3.0.0",
      info: {
        title: "petshop",
        version: "1.0.0",
      },
      paths: {
        "/pet": {
          get: {
            operationId: "AddPet",
            "x-openapi-codegen-component": "useMutate",
            requestBody: {
              content: {
                "application/json": {
                  schema: {
                    type: "object",
                    properties: {
                      name: {
                        type: "string",
                      },
                      color: {
                        type: "string",
                      },
                      breed: {
                        type: "string",
                      },
                      age: {
                        type: "integer",
                      },
                    },
                    required: ["name", "breed", "age"],
                  },
                },
              },
            },
            responses: {
              200: {
                content: {
                  "application/json": {
                    description: "Successful response",
                    schema: {
                      type: "string",
                    },
                  },
                },
              },
              500: {
                content: {
                  "application/json": {
                    description: "An Error",
                    schema: {
                      type: "object",
                      properties: {
                        code: {
                          type: "integer",
                          enum: [500],
                        },
                        message: {
                          type: "string",
                        },
                      },
                      required: ["code", "message"],
                    },
                  },
                },
              },
            },
          },
        },
      },
    };

    await generateReactQueryComponents(
      {
        openAPIDocument,
        writeFile,
        existsFile: () => true,
        readFile: async () => "",
      },
      config,
    );

    expect(writeFile.mock.calls[0][0]).toBe("petstoreComponents.ts");
    expect(writeFile.mock.calls[0][1]).toMatchInlineSnapshot(`
     "/**
      * Generated by @openapi-codegen
      * 
      * @version 1.0.0
      */
     import * as reactQuery from "@tanstack/react-query";
     import { usePetstoreContext, PetstoreContext } from "./petstoreContext";
     import type * as Fetcher from "./petstoreFetcher";
     import { petstoreFetch } from "./petstoreFetcher";

     export type AddPetError = Fetcher.ErrorWrapper<{
         status: 500;
         payload: {
             code: 500;
             message: string;
         };
     }>;

     export type AddPetRequestBody = {
         name: string;
         color?: string;
         breed: string;
         age: number;
     };

     export type AddPetVariables = {
         body: AddPetRequestBody;
     } & PetstoreContext["fetcherOptions"];

     export const fetchAddPet = (variables: AddPetVariables, signal?: AbortSignal) => petstoreFetch<string, AddPetError, AddPetRequestBody, {}, {}, {}>({ url: "/pet", method: "get", ...variables, signal });

     export const useAddPet = (options?: Omit<reactQuery.UseMutationOptions<string, AddPetError, AddPetVariables>, "mutationFn">) => {
         const { fetcherOptions } = usePetstoreContext();
         return reactQuery.useMutation<string, AddPetError, AddPetVariables>({
             mutationFn: (variables: AddPetVariables) => fetchAddPet({ ...fetcherOptions, ...variables }),
             ...options
         });
     };

     export type QueryOperation = {
         path: string;
         operationId: never;
         variables: unknown;
     };
     "
    `);
  });

  it("should resolve requestBody ref", async () => {
    const writeFile = jest.fn();
    const openAPIDocument: OpenAPIObject = {
      openapi: "3.0.0",
      info: {
        title: "petshop",
        version: "1.0.0",
      },
      components: {
        requestBodies: {
          dog: {
            content: {
              "application/json": {
                schema: {
                  type: "object",
                  properties: {
                    name: {
                      type: "string",
                    },
                    color: {
                      type: "string",
                    },
                    breed: {
                      type: "string",
                    },
                    age: {
                      type: "integer",
                    },
                  },
                  required: ["name", "breed", "age"],
                },
              },
            },
          },
        },
      },
      paths: {
        "/pet": {
          post: {
            operationId: "AddPet",
            requestBody: {
              $ref: "#/components/requestBodies/dog",
            },
            responses: {
              200: {
                content: {
                  "application/json": {
                    description: "Successful response",
                    schema: {
                      type: "string",
                    },
                  },
                },
              },
              500: {
                content: {
                  "application/json": {
                    description: "An Error",
                    schema: {
                      type: "object",
                      properties: {
                        code: {
                          type: "integer",
                          enum: [500],
                        },
                        message: {
                          type: "string",
                        },
                      },
                      required: ["code", "message"],
                    },
                  },
                },
              },
            },
          },
        },
      },
    };

    await generateReactQueryComponents(
      {
        openAPIDocument,
        writeFile,
        existsFile: () => true,
        readFile: async () => "",
      },
      config,
    );

    expect(writeFile.mock.calls[0][0]).toBe("petstoreComponents.ts");
    expect(writeFile.mock.calls[0][1]).toMatchInlineSnapshot(`
     "/**
      * Generated by @openapi-codegen
      * 
      * @version 1.0.0
      */
     import * as reactQuery from "@tanstack/react-query";
     import { usePetstoreContext, PetstoreContext } from "./petstoreContext";
     import type * as Fetcher from "./petstoreFetcher";
     import { petstoreFetch } from "./petstoreFetcher";
     import type * as RequestBodies from "./petstoreRequestBodies";

     export type AddPetError = Fetcher.ErrorWrapper<{
         status: 500;
         payload: {
             code: 500;
             message: string;
         };
     }>;

     export type AddPetVariables = {
         body: RequestBodies.Dog;
     } & PetstoreContext["fetcherOptions"];

     export const fetchAddPet = (variables: AddPetVariables, signal?: AbortSignal) => petstoreFetch<string, AddPetError, RequestBodies.Dog, {}, {}, {}>({ url: "/pet", method: "post", ...variables, signal });

     export const useAddPet = (options?: Omit<reactQuery.UseMutationOptions<string, AddPetError, AddPetVariables>, "mutationFn">) => {
         const { fetcherOptions } = usePetstoreContext();
         return reactQuery.useMutation<string, AddPetError, AddPetVariables>({
             mutationFn: (variables: AddPetVariables) => fetchAddPet({ ...fetcherOptions, ...variables }),
             ...options
         });
     };

     export type QueryOperation = {
         path: string;
         operationId: never;
         variables: unknown;
     };
     "
    `);
  });

  it("should deal with pathParams (snake case)", async () => {
    const writeFile = jest.fn();
    const openAPIDocument: OpenAPIObject = {
      openapi: "3.0.0",
      info: {
        title: "petshop",
        version: "1.0.0",
      },
      components: {
        requestBodies: {
          UpdatePetRequestBody: {
            content: {
              "application/json": {
                schema: {
                  type: "object",
                  properties: {
                    name: {
                      type: "string",
                    },
                  },
                },
              },
            },
          },
        },
      },
      paths: {
        "/pet/{pet_id}": {
          parameters: [
            {
              in: "path",
              name: "pet_id",
              schema: {
                type: "string",
              },
              required: true,
            },
          ],
          put: {
            operationId: "updatePet",
            requestBody: {
              $ref: "#/components/requestBodies/UpdatePetRequestBody",
            },
            responses: {
              200: {
                content: {
                  "application/json": {
                    description: "Successful response",
                    schema: {
                      type: "string",
                    },
                  },
                },
              },
            },
          },
        },
      },
    };
    await generateReactQueryComponents(
      {
        openAPIDocument,
        writeFile,
        existsFile: () => true,
        readFile: async () => "",
      },
      config,
    );

    expect(writeFile.mock.calls[0][0]).toBe("petstoreComponents.ts");
    expect(writeFile.mock.calls[0][1]).toMatchInlineSnapshot(`
     "/**
      * Generated by @openapi-codegen
      * 
      * @version 1.0.0
      */
     import * as reactQuery from "@tanstack/react-query";
     import { usePetstoreContext, PetstoreContext } from "./petstoreContext";
     import type * as Fetcher from "./petstoreFetcher";
     import { petstoreFetch } from "./petstoreFetcher";
     import type * as RequestBodies from "./petstoreRequestBodies";

     export type UpdatePetPathParams = {
         petId: string;
     };

     export type UpdatePetError = Fetcher.ErrorWrapper<undefined>;

     export type UpdatePetVariables = {
         body?: RequestBodies.UpdatePetRequestBody;
         pathParams: UpdatePetPathParams;
     } & PetstoreContext["fetcherOptions"];

     export const fetchUpdatePet = (variables: UpdatePetVariables, signal?: AbortSignal) => petstoreFetch<string, UpdatePetError, RequestBodies.UpdatePetRequestBody, {}, {}, UpdatePetPathParams>({ url: "/pet/{petId}", method: "put", ...variables, signal });

     export const useUpdatePet = (options?: Omit<reactQuery.UseMutationOptions<string, UpdatePetError, UpdatePetVariables>, "mutationFn">) => {
         const { fetcherOptions } = usePetstoreContext();
         return reactQuery.useMutation<string, UpdatePetError, UpdatePetVariables>({
             mutationFn: (variables: UpdatePetVariables) => fetchUpdatePet({ ...fetcherOptions, ...variables }),
             ...options
         });
     };

     export type QueryOperation = {
         path: string;
         operationId: never;
         variables: unknown;
     };
     "
    `);
  });

  it("should deal with pathParams (dash case)", async () => {
    const writeFile = jest.fn();
    const openAPIDocument: OpenAPIObject = {
      openapi: "3.0.0",
      info: {
        title: "petshop",
        version: "1.0.0",
      },
      components: {
        requestBodies: {
          UpdatePetRequestBody: {
            content: {
              "application/json": {
                schema: {
                  type: "object",
                  properties: {
                    name: {
                      type: "string",
                    },
                  },
                },
              },
            },
          },
        },
      },
      paths: {
        "/pet/{pet-id}": {
          parameters: [
            {
              in: "path",
              name: "pet-id",
              schema: {
                type: "string",
              },
              required: true,
            },
          ],
          put: {
            operationId: "updatePet",
            requestBody: {
              $ref: "#/components/requestBodies/UpdatePetRequestBody",
            },
            responses: {
              200: {
                content: {
                  "application/json": {
                    description: "Successful response",
                    schema: {
                      type: "string",
                    },
                  },
                },
              },
            },
          },
        },
      },
    };
    await generateReactQueryComponents(
      {
        openAPIDocument,
        writeFile,
        existsFile: () => true,
        readFile: async () => "",
      },
      config,
    );

    expect(writeFile.mock.calls[0][0]).toBe("petstoreComponents.ts");
    expect(writeFile.mock.calls[0][1]).toMatchInlineSnapshot(`
     "/**
      * Generated by @openapi-codegen
      * 
      * @version 1.0.0
      */
     import * as reactQuery from "@tanstack/react-query";
     import { usePetstoreContext, PetstoreContext } from "./petstoreContext";
     import type * as Fetcher from "./petstoreFetcher";
     import { petstoreFetch } from "./petstoreFetcher";
     import type * as RequestBodies from "./petstoreRequestBodies";

     export type UpdatePetPathParams = {
         petId: string;
     };

     export type UpdatePetError = Fetcher.ErrorWrapper<undefined>;

     export type UpdatePetVariables = {
         body?: RequestBodies.UpdatePetRequestBody;
         pathParams: UpdatePetPathParams;
     } & PetstoreContext["fetcherOptions"];

     export const fetchUpdatePet = (variables: UpdatePetVariables, signal?: AbortSignal) => petstoreFetch<string, UpdatePetError, RequestBodies.UpdatePetRequestBody, {}, {}, UpdatePetPathParams>({ url: "/pet/{petId}", method: "put", ...variables, signal });

     export const useUpdatePet = (options?: Omit<reactQuery.UseMutationOptions<string, UpdatePetError, UpdatePetVariables>, "mutationFn">) => {
         const { fetcherOptions } = usePetstoreContext();
         return reactQuery.useMutation<string, UpdatePetError, UpdatePetVariables>({
             mutationFn: (variables: UpdatePetVariables) => fetchUpdatePet({ ...fetcherOptions, ...variables }),
             ...options
         });
     };

     export type QueryOperation = {
         path: string;
         operationId: never;
         variables: unknown;
     };
     "
    `);
  });

  it("should deal with pathParams (dot case)", async () => {
    const writeFile = jest.fn();
    const openAPIDocument: OpenAPIObject = {
      openapi: "3.0.0",
      info: {
        title: "petshop",
        version: "1.0.0",
      },
      components: {
        requestBodies: {
          UpdatePetRequestBody: {
            content: {
              "application/json": {
                schema: {
                  type: "object",
                  properties: {
                    name: {
                      type: "string",
                    },
                  },
                },
              },
            },
          },
        },
      },
      paths: {
        "/pet/{pet.id}": {
          parameters: [
            {
              in: "path",
              name: "pet.id",
              schema: {
                type: "string",
              },
              required: true,
            },
          ],
          put: {
            operationId: "updatePet",
            requestBody: {
              $ref: "#/components/requestBodies/UpdatePetRequestBody",
            },
            responses: {
              200: {
                content: {
                  "application/json": {
                    description: "Successful response",
                    schema: {
                      type: "string",
                    },
                  },
                },
              },
            },
          },
        },
      },
    };
    await generateReactQueryComponents(
      {
        openAPIDocument,
        writeFile,
        existsFile: () => true,
        readFile: async () => "",
      },
      config,
    );

    expect(writeFile.mock.calls[0][0]).toBe("petstoreComponents.ts");
    expect(writeFile.mock.calls[0][1]).toMatchInlineSnapshot(`
     "/**
      * Generated by @openapi-codegen
      * 
      * @version 1.0.0
      */
     import * as reactQuery from "@tanstack/react-query";
     import { usePetstoreContext, PetstoreContext } from "./petstoreContext";
     import type * as Fetcher from "./petstoreFetcher";
     import { petstoreFetch } from "./petstoreFetcher";
     import type * as RequestBodies from "./petstoreRequestBodies";

     export type UpdatePetPathParams = {
         petId: string;
     };

     export type UpdatePetError = Fetcher.ErrorWrapper<undefined>;

     export type UpdatePetVariables = {
         body?: RequestBodies.UpdatePetRequestBody;
         pathParams: UpdatePetPathParams;
     } & PetstoreContext["fetcherOptions"];

     export const fetchUpdatePet = (variables: UpdatePetVariables, signal?: AbortSignal) => petstoreFetch<string, UpdatePetError, RequestBodies.UpdatePetRequestBody, {}, {}, UpdatePetPathParams>({ url: "/pet/{petId}", method: "put", ...variables, signal });

     export const useUpdatePet = (options?: Omit<reactQuery.UseMutationOptions<string, UpdatePetError, UpdatePetVariables>, "mutationFn">) => {
         const { fetcherOptions } = usePetstoreContext();
         return reactQuery.useMutation<string, UpdatePetError, UpdatePetVariables>({
             mutationFn: (variables: UpdatePetVariables) => fetchUpdatePet({ ...fetcherOptions, ...variables }),
             ...options
         });
     };

     export type QueryOperation = {
         path: string;
         operationId: never;
         variables: unknown;
     };
     "
    `);
  });

  it("should build components without prefix", async () => {
    const writeFile = jest.fn();
    const openAPIDocument: OpenAPIObject = {
      openapi: "3.0.0",
      info: {
        title: "petshop",
        version: "1.0.0",
      },
      components: {
        requestBodies: {
          UpdatePetRequestBody: {
            content: {
              "application/json": {
                schema: {
                  type: "object",
                  properties: {
                    name: {
                      type: "string",
                    },
                  },
                },
              },
            },
          },
        },
      },
      paths: {
        "/pet/{pet_id}": {
          parameters: [
            {
              in: "path",
              name: "pet_id",
              schema: {
                type: "string",
              },
              required: true,
            },
          ],
          put: {
            operationId: "updatePet",
            requestBody: {
              $ref: "#/components/requestBodies/UpdatePetRequestBody",
            },
            responses: {
              200: {
                content: {
                  "application/json": {
                    description: "Successful response",
                    schema: {
                      type: "string",
                    },
                  },
                },
              },
            },
          },
        },
      },
    };
    await generateReactQueryComponents(
      {
        openAPIDocument,
        writeFile,
        existsFile: () => true,
        readFile: async () => "",
      },
      { ...config, filenamePrefix: "" },
    );

    expect(writeFile.mock.calls[0][0]).toBe("components.ts");
    expect(writeFile.mock.calls[0][1]).toMatchInlineSnapshot(`
     "/**
      * Generated by @openapi-codegen
      * 
      * @version 1.0.0
      */
     import * as reactQuery from "@tanstack/react-query";
     import { useContext, Context } from "./context";
     import type * as Fetcher from "./fetcher";
     import { fetch } from "./fetcher";
     import type * as RequestBodies from "./petstoreRequestBodies";

     export type UpdatePetPathParams = {
         petId: string;
     };

     export type UpdatePetError = Fetcher.ErrorWrapper<undefined>;

     export type UpdatePetVariables = {
         body?: RequestBodies.UpdatePetRequestBody;
         pathParams: UpdatePetPathParams;
     } & Context["fetcherOptions"];

     export const fetchUpdatePet = (variables: UpdatePetVariables, signal?: AbortSignal) => fetch<string, UpdatePetError, RequestBodies.UpdatePetRequestBody, {}, {}, UpdatePetPathParams>({ url: "/pet/{petId}", method: "put", ...variables, signal });

     export const useUpdatePet = (options?: Omit<reactQuery.UseMutationOptions<string, UpdatePetError, UpdatePetVariables>, "mutationFn">) => {
         const { fetcherOptions } = useContext();
         return reactQuery.useMutation<string, UpdatePetError, UpdatePetVariables>({
             mutationFn: (variables: UpdatePetVariables) => fetchUpdatePet({ ...fetcherOptions, ...variables }),
             ...options
         });
     };

     export type QueryOperation = {
         path: string;
         operationId: never;
         variables: unknown;
     };
     "
    `);
  });

  it("should generate utils file if needed", async () => {
    const writeFile = jest.fn();
    const openAPIDocument: OpenAPIObject = {
      openapi: "3.0.0",
      info: {
        title: "petshop",
        version: "1.0.0",
      },
      paths: {
        "/pets": {
          get: {
            operationId: "listPets",
            description: "Get all the pets",
            responses: {
              "200": {
                description: "pet response",
                content: {
                  "application/json": {
                    schema: {
                      type: "array",
                      items: {
                        $ref: "#/components/schemas/Pet",
                      },
                    },
                  },
                },
              },
              "5xx": {
                description: "Server error",
                content: {
                  "application/json": {
                    schema: {
                      type: "string",
                    },
                  },
                },
              },
            },
          },
        },
      },
    };

    await generateReactQueryComponents(
      {
        openAPIDocument,
        writeFile,
        existsFile: () => true,
        readFile: async () => "",
      },
      config,
    );

    expect(writeFile.mock.calls[0][0]).toBe("petstoreUtils.ts");
    expect(writeFile.mock.calls[1][1]).toMatchInlineSnapshot(`
     "/**
      * Generated by @openapi-codegen
      * 
      * @version 1.0.0
      */
     import * as reactQuery from "@tanstack/react-query";
     import { usePetstoreContext, PetstoreContext } from "./petstoreContext";
     import type * as Fetcher from "./petstoreFetcher";
     import { petstoreFetch } from "./petstoreFetcher";
     import type * as Schemas from "./petstoreSchemas";
     import type { ServerErrorStatus } from "./petstoreUtils";

     export type ListPetsError = Fetcher.ErrorWrapper<{
         status: ServerErrorStatus;
         payload: string;
     }>;

     export type ListPetsResponse = Schemas.Pet[];

     export type ListPetsVariables = PetstoreContext["fetcherOptions"];

     /**
      * Get all the pets
      */
     export const fetchListPets = (variables: ListPetsVariables, signal?: AbortSignal) => petstoreFetch<ListPetsResponse, ListPetsError, undefined, {}, {}, {}>({ url: "/pets", method: "get", ...variables, signal });

     /**
      * Get all the pets
      */
     export const useListPets = <TData = ListPetsResponse>(variables: ListPetsVariables, options?: Omit<reactQuery.UseQueryOptions<ListPetsResponse, ListPetsError, TData>, "queryKey" | "queryFn" | "initialData">) => { const { fetcherOptions, queryOptions, queryKeyFn } = usePetstoreContext(options); return reactQuery.useQuery<ListPetsResponse, ListPetsError, TData>({
         queryKey: queryKeyFn({ path: "/pets", operationId: "listPets", variables }),
         queryFn: ({ signal }) => fetchListPets({ ...fetcherOptions, ...variables }, signal),
         ...options,
         ...queryOptions
     }); };

     export type QueryOperation = {
         path: "/pets";
         operationId: "listPets";
         variables: ListPetsVariables;
     };
     "
    `);
  });
});
